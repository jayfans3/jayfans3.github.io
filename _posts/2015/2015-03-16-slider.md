<html>
<head>
  <title>客户端得到代理，使用协议</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274061; Windows/6.1.7600;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="566"/>

# 客户端得到代理，使用协议

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>客户端得到代理，使用协议</div><div>RpcBinder：</div><div>
</div><div>?public static SliderClusterProtocol connectToServer(InetSocketAddress addr,

??????????????????????????????????????????????????? UserGroupInformation currentUser,

??????????????????????????????????????????????????? Configuration conf,

??????????????????????????????????????????????????? int rpcTimeout) throws IOException {

??? Class&lt;SliderClusterProtocolPB&gt; sliderClusterAPIClass = registerSliderAPI(

??????? conf);

??? log.debug(&quot;Connecting to Slider AM at {}&quot;, addr);

??? ProtocolProxy&lt;SliderClusterProtocolPB&gt; protoProxy =

????? RPC.getProtocolProxy(sliderClusterAPIClass,

?????????????????????????? 1,

?????????????????????????? addr,

?????????????????????????? currentUser,

?????????????????????????? conf,

?????????????????????????? NetUtils.getDefaultSocketFactory(conf),

?????????????????????????? rpcTimeout,

?????????????????????????? null);

??? SliderClusterProtocolPB endpoint = protoProxy.getProxy();

??? return new SliderClusterProtocolProxy(endpoint);

? }</div><div>? liderClusterProtocolProxy implements SliderClusterProtocol ,代理帮助客户端来操作SliderClusterProtocolPB?endpoint句柄，通过PB来取得结果</div><div>
</div><div>
</div><div>getProtocolEngine(protocol,conf).getProxy(protocol, clientVersion,

??????? addr, ticket, conf, factory, rpcTimeout, connectionRetryPolicy);</div><div>
</div><div>
</div><div>
</div><div>具体的SERVICE端调用一样会使用</div><div>
</div></div>
</div></body></html> 